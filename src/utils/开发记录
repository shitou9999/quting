https://www.npmjs.com/package/rn-project
https://github.com/sunnylqm/react-native-coding-style
AqRNzhUtm9B53rqBA3trA_qAX5z0oDuT9y-FGF-yyEzf
********************
this.setState({}) 不能做逻辑处理
********************
JS中将一个值转换为字符串的3种方法
1.value.toString()--->不能把null和undefined转换为字符串
2."" + value
3.String(value)

this._onChangeText = this._onChangeText.bind(this);

   _onChangeText(inputData){
        console.log("输入的内容",inputData);
        //把获取到的内容，设置给showValue
        this.setState({showValue:inputData});
    }

   onChangeText={this._onChangeText}//输入框改变触发的函数

Label
   - xl: 超大, 在默认 Theme 中定义的字体大小为 26
   - lg: 大, 在默认 Theme 中定义的字体大小为 20
   - md: 中, 在默认 Theme 中定义的字体大小为 14
   - sm: 小, 在默认 Theme 中定义的字体大小为 10
   - xs: 超小, 在默认 Theme 中定义的字体大小为 8

//图片选择ios,启动白屏ios
TouchableWithoutFeedback：响应用户的点击事件，如果你想在处理点击事件的同时不显示任何视觉反馈，使用它是个不错的选择。
TouchableHighlight：在TouchableWithoutFeedback的基础上添加了当按下时背景会变暗的效果。
TouchableOpacity：相比TouchableHighlight在按下去会使背景变暗的效果，TouchableOpacity会在用户手指按下时降低按钮的透明度，而不会改变背景的颜色。
TouchableNativeFeedback：在Android上还可以使用TouchableNativeFeedback，它会在用户手指按下时形成类似水波纹的视觉效果。注意，此组件只支持Android。

*****************(View)****************
    onMagicTap：当accessible为true时，双击View会调用此函数。
    onMoveShouldSetResponder：触摸控件并滑动时调用的方法
    onMoveShouldSetResponderCapture：触摸控件并滑动时调用的方法,避免子视图响应
    onResponderMove：用户在View上移动手指调用
    onResponderRelease：结束触摸时调用
    pointerEvents：控制当前视图是否可以触控'box-none', 'none', 'box-only', 'auto'

width：宽度
height：高度
backgroundColor：背景颜色
backfaceVisibility：是否显示翻转'visible'，'hidden'
borderColor：边框颜色
borderWidth：边框宽度
borderRadius：边框圆角半径
borderStyle：边框样式'solid'实线，'dotted'点， 'dashed'虚线
borderTopColor：上边框颜色
borderTopWidth：上边框宽度
borderTopLeftRadius：左上角边框圆角的半径
borderTopRightRadius：右上角边框圆角的半径
overflow：内容超过容器时超出显示还是隐藏'visible'， 'hidden'
opacity：透明度

***********************(Text)*************************************
adjustsFontSizeToFit   Boolean   指定字体是否随着给定样式的限制而自动缩放
allowFontScaling   Boolean  控制字体是否要根据系统的“字体大小”辅助选项来进行缩放。
minimumFontScale  Boolean  当adjustsFontSizeToFit开启时，指定最小的缩放比（即不能低于这个值）。可设定的值为0.01 - 1.0
numberOfLines   Number   用来当文本过长的时候裁剪文本。包括折叠产生的换行在内，总的行数不会超过这个属性的限制。numberOfLines={3}
onLayout    Function   当挂载或者布局变化以后调用，参数为如下的内容：{nativeEvent: {layout: {x, y, width, height}}}
onLongPress   Function   当文本被长按以后调用此回调函数。
onPress  Function   当文本被点击以后调用此回调函数。
selectable   决定用户是否可以长按选择文本，以便复制和粘贴。
style   自定义样式
color
fontFamily
fontSize
fontStyle
fontWeight ->大多数字体都支持normal和bold的值，并非所有字体都支持所有的数值。若不支持贼选择最接近的值
lineHeight
textAlign
textDecorationLine
textShadowColor
textShadowOffset
textShadowRadius

***********************Image*************************************
https://blog.csdn.net/yeshaojian/article/details/52965704
FlexBox：支持弹性盒子风格
Transforms：支持属性动画
backgroundcolor：背景颜色
borderColor：边框颜色
borderWidth：边框宽度
borderRadius：边框圆角
overflow：设置图片尺寸超过容器可以设置显示或隐藏(‘visible’, ‘hidden’)
tintColor：颜色设置
opacity：设置透明度（取值范围0.0（全透明）~ 1.0（不透明））
************************************************************
color: 'transparent'
flexDirection 项目的排列方向

父视图属性(容器属性)：
flexDirection
flexWrap子元素在父视图内是否允许多行排列,子元素在父视图内是否允许多行排列,,,可能导致溢出
justifyContent
alignItems侧轴的排列方式

子视图属性
alignSelf enum(‘auto’, ‘flex-start’, ‘flex-end’, ‘center’, ‘stretch’)
flex number

auto(default) 元素继承了它的父容器的 align-items 属性。如果没有父容器则为 “stretch”。
stretch 元素被拉伸以适应容器。
center 元素位于容器的中心。
flex-start 元素位于容器的开头。
flex-end 元素位于容器的结尾。
************************************************************

container: {
    flexDirection:'row', //主轴水平，起点在左，默认值
    flexDirection:'column', //主轴垂直，起点在上
    flexDirection:'row-reverse', //主轴水平，起点在右，
    flexDirection:'column-reverse', //主轴垂直，起点在下
}

flexFlow 默认情况下，项目都排在一条直线上，主要定义如果一条直线排不下，如何换行
container: {
    flexWrap:'nowrap', // 不换行， 默认
    flexWrap:'wrap', // 换行，第一行在上方
    flexWrap:'wrap-reverse', // 换行，第一行在下方
}

//justifyContent---->定义了主轴上的对齐方式
container: {
    justifyContent:'flex-start', // 左对齐，默认值
    justifyContent:'flex-end', // 右对齐
    justifyContent:'center', // 居中
    justifyContent:'space-between', // 两端对齐，项目之间间隔相等
    justifyContent:'space-around', // 每个项目两端的间隔相等。所以项目间的间隔比项目与边框的间隔大一倍,,space-around 在每行上均匀分配弹性元素。
}

alignItems 在交叉轴上如何对齐，只有在flexDirection为column时
container: {
    alignItems:'flex-start', // 交叉轴起点对齐
    alignItems:'flex-end', // 交叉轴终点对齐
    alignItems:'center', // 交叉轴中点对齐
    alignItems:'baseline', // 项目第一行文字的基线对齐
    alignItems:'stretch', // 如果项目未设置高度或设为auto，将占满整个容器的高度
}

alignContent 定义了多根轴线的对齐方式，如果项目只有一根轴线，该属性不起作用
container: {
    alignContent:'flex-start', // 与交叉轴的起点对齐
    alignContent:'flex-end', // 与交叉轴的终点对齐
    alignContent:'center', // 与交叉轴的中点对齐
    alignContent:'space-between', // 与交叉轴两端对齐，轴线之间的间距间隔平均分布
    alignContent:'space-around', // 每根轴线两侧的间隔相等
    alignContent:'stretch', // 轴线占满整个交叉轴，默认值
}
************************************************************
borderBottomWidth number 底部边框宽度
borderLeftWidth number 左边框宽度
borderRightWidth number 右边框宽度
borderTopWidth number 顶部边框宽度
borderWidth number 边框宽度
border<Bottom	Left	Right	Top>Color 个方向边框的颜色
borderColor 边框颜色

margin number 外边距
marginBottom number 下外边距
marginHorizontal number 左右外边距
marginLeft number 左外边距
marginRight number 右外边距
marginTop number 上外边距
marginVertical number 上下外边距

padding number 内边距
paddingBottom number 下内边距
paddingHorizontal number 左右内边距
paddingLeft number 做内边距
paddingRight number 右内边距
paddingTop number 上内边距
paddingVertical number 上下内边距
************************************************************
position enum(‘absolute’, ‘relative’)属性设置元素的定位方式，为将要定位的元素定义定位规则。
absolute：生成绝对定位的元素，元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。
relative：生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。
************************************************************
//     textAlign: 'center',
//     textAlignVertical: 'center',
data:image/png;base64,
还可以使用@2x，@3x这样的文件名后缀，来为不同的屏幕精度提供图片
我们在使用具有不同分辨率的图标时，一定要引用标准分辨率的图片如require('./img/check.png')，
如果我们这样写require('./img/check@2x.png')，那么应用在不同分辨率的设备上都只会显示check@2x.png图片，也就无法达到图片自适配的效果。

require中不能用字符串拼接路径，否则会加载报错
<Image style={styles.img}
              source={{uri: this.state.imgs[this.state.count]}}
              resizeMode="contain" />
source={{uri: 'https://www.baidu.com/img/bd_logo1.png'}}
source={require('../assets/images/me_bg.png')}>

   Image.resizeMode.cover：图片居中显示，没有被拉伸，超出部分被截断；
   Image.resizeMode.contain：容器完全容纳图片，图片等比例进拉伸；
   Image.resizeMode.stretch： 图片被拉伸适应容器大小，有可能会发生变形。

  cover 模式（默认值）----有丢弃
  要求图片能够填充整个 Image 组件定义的显示区域，可以对图片进行放大或者缩小，可以丢弃放大或缩小后的图片中的部分区域，只求在显示比例不失真的情况下填充整个显示区域。

  contain 模式 -----等比放大或缩小，有可能显示区域空白
  该模式要求显示整张图片，可以对它进行等比放大或者缩小，但不能丢弃改变后图片的某部分。这个模式下图片得到完整的呈现，比例不会变。但图片可能无法填充 Image 的所有区域，会在侧边或者上下留下空白，由 Image 组件的底色填充
  resizeMode="contain"，这样图片就会在指定大小内自适应缩放

   stretch 模式----->任意缩放，会失真
   该模式要求图片填充整个 Image 定义的显示区域，因此会对图片进行任意的缩放，不考虑保持图片原来的宽、高比。这种模式显示出来的图片有可能会出现明显的失真。

    center 模式------》
    该模式要求图片图片位于显示区域的中心。这种模式下图片可能也无法填充 Image 的所有区域，会在侧边或者上下留下空白，由 Image 组件的底色填充。

alignItems水平布局
alignItems 决定你控件的位于屏幕的竖向 左右中 位置 flex-start(左或上) center flex-end(右或下) stretch


//postion定位
relative——相对定位------》以元素本来的位置为基准进行偏移。
absolute——绝对定位==----》以父元素的边框为基准进行偏移。

    flex: {
        flex: 1,
    },
    flexDirectionRow: {
        flexDirection: 'row',
        flex: 1,
    },
    flexDirectionColumn: {
        flexDirection: "column",//布局中子视图排放的方向
        flex: 1,
    },
    flexDirectionRowNotFlex: {
        flexDirection: 'row',
    },
    flexDirectionColumnNotFlex: {
        flexDirection: "column",
    },
    justifyCenter: {
        justifyContent: "center"//子元素沿着主轴的排列方式
    },
    centered: {
        justifyContent: "center",
        alignItems: "center"
    },
    centerV: {
        justifyContent: "center",
    },
    centerH: {
        alignItems: "center"
    },
    justifyBetween: {
        justifyContent: "space-between"
    },
    alignItemsEnd: {
        alignItems: "flex-end"
    },
    justifyEnd: {
        justifyContent: "flex-end"
    },

    // const aliObj = {
        //     orderString: 'orderString'
        // }
        // Pay.onAliPay(JSON.stringify(aliObj)).then(e => console.info(e)).catch(err => alert(err))

 // storage.load("PROBLEM+TYPE", (results) => {
        //     console.log(results)//(2) [{…}, {…}]
        //     results.forEach(result => {
        //         console.log(result.lookupValue);
        //     })
        // })
        //读取单个字典
        gStorage.storage.loadId("PROBLEM+TYPE", 1, results => {
            console.log(results)
        })
        //读取某一类字典[]
        gStorage.storage.getAllDataForKey('PROBLEM+TYPE', users => {
            console.log(users);
        });

    // getItemLayout属性是一个可选的优化，用于避免动态测量内容尺寸的开销。如果我们知道item的高度，就可以为FlatList指定这一个属性，来使FlatList更加高效的运行！
    // getItemLayout={(data, index) => ({
//     length: 44, offset: (44 + 1) * index, index
// })}

<ScrollView
                    ref={(scroll) => this._scroll = scroll}
                    keyboardDismissMode='on-drag'
                    keyboardShouldPersistTaps='never'
                    showsVerticalScrollIndicator={true}
                    scrollEnabled={true}
                    pagingEnabled={true}
                    horizontal={false}
                    style={{flex: 1}}
                    onScroll={(e) => {
                        console.warn('onScroll');
                    }}>






